<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>学无止境</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="程序猿的世界多精彩">
<meta property="og:type" content="website">
<meta property="og:title" content="学无止境">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="学无止境">
<meta property="og:description" content="程序猿的世界多精彩">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学无止境">
<meta name="twitter:description" content="程序猿的世界多精彩">
  
    <link rel="alternate" href="/atom.xml" title="学无止境" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学无止境</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">蕴含文艺气息的程序猿</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-NSCache初识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/25/NSCache初识/" class="article-date">
  <time datetime="2016-07-25T12:08:53.000Z" itemprop="datePublished">2016-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/25/NSCache初识/">NSCache初识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="我们主要比较一下NSCache-与-NSMutableDictionary的区别"><a href="#我们主要比较一下NSCache-与-NSMutableDictionary的区别" class="headerlink" title="我们主要比较一下NSCache 与 NSMutableDictionary的区别"></a>我们主要比较一下NSCache 与 NSMutableDictionary的区别</h3><blockquote>
<p>现在demo的代码贴上，下面我们会围绕代码讲解</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSCache</span> *cache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *dictCache;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    _cache = [[<span class="built_in">NSCache</span> alloc] init];</div><div class="line">    _dictCache = [[ <span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">    </div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> writeCache];</div><div class="line">    [<span class="keyword">self</span> readCache];</div><div class="line">    [<span class="keyword">self</span> writeDictCache];</div><div class="line">    [<span class="keyword">self</span> readDictCache];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)writeCache</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *imageUrl = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"qqImage"</span> withExtension:<span class="string">@"png"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSTimeInterval</span> timeInterval = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>,count = <span class="number">1000</span>; i &lt; count; i++)</div><div class="line">    &#123;</div><div class="line">        [_cache setObject:data forKey:@(i)];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cache write time : %f"</span>,([[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - timeInterval));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)readCache</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSTimeInterval</span> timeInterval = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>,count = <span class="number">1000</span>; i &lt; count; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [_cache objectForKey:@(i)];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (i % <span class="number">333</span> == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"data index and length : %@ and %lu"</span>,@(i) ,data.length);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cache read time : %f"</span>,([[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - timeInterval));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)writeDictCache</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *imageUrl = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"qqImage"</span> withExtension:<span class="string">@"png"</span>];</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</div><div class="line">    <span class="built_in">NSTimeInterval</span> timeInterval = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>,count = <span class="number">1000</span>; i &lt; count; i++)</div><div class="line">    &#123;</div><div class="line">        [_dictCache setObject:data forKey:@(i)];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dictinary write time : %f"</span>,([[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - timeInterval));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)readDictCache</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSTimeInterval</span> timeInterval = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>,count = <span class="number">1000</span>; i &lt; count; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [_dictCache objectForKey:@(i)];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (i % <span class="number">333</span> == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"dictionary data index and length : %@ and %lu"</span>,@(i) ,data.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dictionary read time : %f"</span>,([[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - timeInterval));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-比较两者的读写速度：我们用我们用模拟器（不会内存警告）运行一下："><a href="#1-比较两者的读写速度：我们用我们用模拟器（不会内存警告）运行一下：" class="headerlink" title="1.比较两者的读写速度：我们用我们用模拟器（不会内存警告）运行一下："></a>1.比较两者的读写速度：我们用我们用模拟器（不会内存警告）运行一下：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.934</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] dictinary write time : <span class="number">0.000213</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.935</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] dictionary data index and length : <span class="number">0</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.935</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] dictionary data index and length : <span class="number">333</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.935</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] dictionary data index and length : <span class="number">666</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.935</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] dictionary data index and length : <span class="number">999</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.935</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] dictionary read time : <span class="number">0.000700</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.937</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] cache write time : <span class="number">0.001076</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.937</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] data index and length : <span class="number">0</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.937</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] data index and length : <span class="number">333</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.937</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] data index and length : <span class="number">666</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.937</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] data index and length : <span class="number">999</span> and <span class="number">477598</span></div><div class="line"><span class="number">2016</span><span class="number">-07</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">57</span>:<span class="number">48.937</span> TestFirstObject[<span class="number">13431</span>:<span class="number">340406</span>] cache read time : <span class="number">0.000789</span></div></pre></td></tr></table></figure>
<p>通过打印日志我们看到无所写入速度还是读取速度，nsmutabledictionary 比 nscache稍快一点，不过对比477598bytes的data写入1000次才有毫秒级的差距来看，速度相差几乎何以忽略。</p>
<h3 id="2-NSCache-具有自动清除功能。"><a href="#2-NSCache-具有自动清除功能。" class="headerlink" title="2.NSCache 具有自动清除功能。"></a>2.NSCache 具有自动清除功能。</h3><p>当我们在真机上执行的时候，如下代码，写入1000次data<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>,count = <span class="number">1000</span>; i &lt; count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</div><div class="line">    [_cache setObject:data forKey:@(i)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于数据的庞大，执行这块代码之后，系统会发出内存警告，这时会调用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> didReceiveMemoryWarning];</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"**** %@ *****"</span>,<span class="built_in">NSStringFromSelector</span>(_cmd));</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> readCache];</div><div class="line">    [<span class="keyword">self</span> readDictCache];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当接收到内存警告之后，再次readCache会发现_cache里面缓存的数据都被清除了，而_dictCache里面的数据则没有被清除掉。</p>
<h3 id="3-NSCache是线程安全的，而NSMutableDcitionary等可变容器是线程不安全的。"><a href="#3-NSCache是线程安全的，而NSMutableDcitionary等可变容器是线程不安全的。" class="headerlink" title="3.NSCache是线程安全的，而NSMutableDcitionary等可变容器是线程不安全的。"></a>3.NSCache是线程安全的，而NSMutableDcitionary等可变容器是线程不安全的。</h3><h3 id="4-NSCache的key不需要copy，NSMutableDcitionary的key需要实现NSCopying协议。"><a href="#4-NSCache的key不需要copy，NSMutableDcitionary的key需要实现NSCopying协议。" class="headerlink" title="4.NSCache的key不需要copy，NSMutableDcitionary的key需要实现NSCopying协议。"></a>4.NSCache的key不需要copy，NSMutableDcitionary的key需要实现NSCopying协议。</h3><h3 id="5-void-setObject-ObjectType-obj-forKey-KeyType-key-cost-NSUInteger-g"><a href="#5-void-setObject-ObjectType-obj-forKey-KeyType-key-cost-NSUInteger-g" class="headerlink" title="5.- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;"></a>5.- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;</h3><p>cost是缓存成本，比如SDWebimage框架计算cost值<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_STATIC_INLINE <span class="built_in">NSUInteger</span> SDCacheCostForImage(<span class="built_in">UIImage</span> *image) &#123;</div><div class="line">    <span class="keyword">return</span> image.size.height * image.size.width * image.scale * image.scale;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然而我们最好不要这么用，我在demo中尝试使用这个方法，发现并没有卵用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)writeCache</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *imageUrl = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"qqImage"</span> withExtension:<span class="string">@"png"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSTimeInterval</span> timeInterval = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970];</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageUrl];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>,count = <span class="number">1000</span>; i &lt; count; i++)</div><div class="line">    &#123;</div><div class="line">        [_cache setObject:data forKey:@(i) cost:<span class="number">5</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"cache write time : %f"</span>,([[<span class="built_in">NSDate</span> date] timeIntervalSince1970] - timeInterval));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/25/NSCache初识/" data-id="cir1zqqne00017p5h8l5wytde" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDWebImage源码分析_02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/22/SDWebImage源码分析_02/" class="article-date">
  <time datetime="2016-07-22T12:59:24.000Z" itemprop="datePublished">2016-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/22/SDWebImage源码分析_02/">SDWebImage源码分析_02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接续上一篇内容，首先我们看一下SDWebImageCombinedOperation这个类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCombinedOperation</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageOperation</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) SDWebImageNoParamsBlock cancelBlock;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperation</span> *cacheOperation;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这里面主要保存了两个东西cancelBlock可以取消operation，cacheOperation用来下载图片并且缓存。</p>
<h3 id="下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中"><a href="#下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中" class="headerlink" title="下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中."></a>下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中.</h3><p>下面这个方法主要作用是异步查询图片缓存，分别从内存中查询和磁盘中查询，也是这个类的主要方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!doneBlock) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        doneBlock(<span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// First check the in-memory cache...</span></div><div class="line">    <span class="comment">// 1.首先查看内存缓存,如果查找到,则直接调用doneBlock并返回</span></div><div class="line">    <span class="comment">//这个 imageFromMemoryCacheForKey 方法会在 SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据, 而 memCache 就是一个 NSCache.</span></div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//2.如果内存中没有,则在磁盘中查找,如果找到,则将其放到内存缓存中,并调用doneBlock回调</span></div><div class="line">    <span class="comment">/*如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..*/</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    </div><div class="line">    <span class="comment">//在ioQueue中串行处理所有磁盘缓存</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//创建自动释放池,内存及时释放</span></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="comment">/* 在这里会调用一个方法 diskImageForKey, 这里文件名字的存储使用 MD5 处理过后的文件名，存储的内容是image的data数据*/</span></div><div class="line">            <span class="comment">//根据图片的url对应的key去磁盘缓存中查找图片</span></div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            </div><div class="line">            <span class="comment">// 获取图片后缓存到内存中</span></div><div class="line">            <span class="comment">//如果可以在磁盘中查找到image,并且self.shouldCacheImagesInMemory = YES(默认是YES,if memory cache is enabled)就将image储存到内存缓存中</span></div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                </div><div class="line">                <span class="comment">//self.memCache是NSCache创建的一个对象,下面的方法是NSCache储存对象的方法</span></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 在缓存中设置指定键名对应的值，并且指定该键值对的成本。当出现内存警告时，或者超出缓存的总成本上限时，缓存会开启一个回收过程，删除部分元素</div><div class="line">                 @param cost 成本 (cost) 用于计算记录在缓冲中的所有对象的总成本</div><div class="line">                 */</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//最后在主线程里面调用doneBlock返回</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法中imageFromMemoryCacheForKey和diskImageForKey分别是从内存中查找和从磁盘中查找，下面我们看一下这两个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上方法memCache是NSCache类型的属性，图片的缓存即是通过这个存储在内存中。</p>
<p>接着我们看磁盘缓存<br>在这里会调用一个方法 diskImageForKey, 这里文件名字的存储使用 MD5 处理过后的文件名，存储的内容是image的data数据<br>根据图片的url对应的key去磁盘缓存中查找图片<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)diskImageForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">    <span class="keyword">if</span> (data) &#123;</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:data];</div><div class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">            image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这些方法，把url用md5加密，拼接成filename，CC_MD5_DIGEST_LENGTH这个宏定义 = 16，r[16]开辟16字节的存储空间，然后把filename和文件路径绑定在一起。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单封装了cachePathForKey:inPath</span></div><div class="line">- (<span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cachePathForKey:key inPath:<span class="keyword">self</span>.diskCachePath];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// cachePathForKey:inPath</span></div><div class="line">- (<span class="built_in">NSString</span> *)cachePathForKey:(<span class="built_in">NSString</span> *)key inPath:(<span class="built_in">NSString</span> *)path &#123;</div><div class="line"><span class="comment">// 根据传入的key创建最终要存储时的文件名</span></div><div class="line"><span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> cachedFileNameForKey:key];</div><div class="line"><span class="comment">// 将存储的文件路径和文件名绑定在一起，作为最终的存储路径</span></div><div class="line"><span class="keyword">return</span> [path stringByAppendingPathComponent:filename];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// cachedFileNameForKey:</span></div><div class="line"><span class="comment">// 这个方法就是把key值即url，转化成32位16进制数，然后加上扩展名，座位文件名字。</span></div><div class="line">- (<span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = [key UTF8String];</div><div class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</div><div class="line">    str = <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用了MD5进行加密处理</span></div><div class="line"><span class="comment">// 开辟一个16字节（128位：md5加密出来就是128bit）的空间</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</div><div class="line"><span class="comment">// 官方封装好的加密方法</span></div><div class="line"><span class="comment">// 把str字符串转换成了32位的16进制数列（这个过程不可逆转） 存储到了r这个空间中</span></div><div class="line">CC_MD5(str, (CC_LONG)strlen(str), r);</div><div class="line"><span class="comment">// 最终生成的文件名就是 "md5码"+".文件类型"</span></div><div class="line"><span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</div><div class="line">                      r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</div><div class="line">                      r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], [[key pathExtension] isEqualToString:<span class="string">@""</span>] ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, [key pathExtension]]];</div><div class="line"></div><div class="line"><span class="keyword">return</span> filename;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。"><a href="#至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。" class="headerlink" title="至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。"></a>至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageDownloaderOperation *operation;</div><div class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//创建下载的回调,我们开始来看看创建完下载的回调之后里面都写了什么事情</span></div><div class="line">        </div><div class="line">        <span class="comment">/* 请求超时时间*/</span></div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = wself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        <span class="comment">// 初始化NSMutableURLRequest 这个 request 就用于在之后发送 HTTP 请求</span></div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         创建请求对象,并根据options参数设置其属性</div><div class="line">         为了避免潜在的重复缓存(NSURLCache + SDImageCache)，</div><div class="line">         如果没有明确告知需要缓存，</div><div class="line">         则禁用图片请求的缓存操作, 这样就只有SDImageCache进行了缓存</div><div class="line">         这里的options 是SDWebImageDownloaderOptions</div><div class="line">         */</div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        <span class="comment">// 通过设置 NSMutableURLRequest.HTTPShouldHandleCookies = YES</span></div><div class="line">        <span class="comment">//的方式来处理存储在NSHTTPCookieStore的cookies</span></div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        <span class="comment">//返回在接到上一个请求得得响应之前,饰扣需要传输数据,YES传输,NO不传输</span></div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         如果你自定义了wself.headersFilter,那就用你自己设置的</div><div class="line">         wself.headersFilter来设置HTTP的header field</div><div class="line">         它的定义是</div><div class="line">         typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</div><div class="line">         一个返回结果为NSDictionary类型的block</div><div class="line">         </div><div class="line">         如果你没有自己设置wself.headersFilter那么就用SDWebImage提供的HTTPHeaders</div><div class="line">         HTTPHeaders在#import "SDWebImageDownloader.h",init方法里面初始化,下载webp图片需要的header不一样</div><div class="line">         (WebP格式，[谷歌]开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间)</div><div class="line">         #ifdef SD_WEBP</div><div class="line">         _HTTPHeaders = [@&#123;@"Accept": @"image/webp,image/*;q=0.8"&#125; mutableCopy];</div><div class="line">         #else</div><div class="line">         _HTTPHeaders = [@&#123;@"Accept": @"image/*;q=0.8"&#125; mutableCopy];</div><div class="line">         #endif</div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/* 在初始化了这个 request 之后, 又初始化了一个 SDWebImageDownloaderOperation 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 NSOperation 的子类*/</span></div><div class="line">        </div><div class="line">        <span class="comment">/*但是在初始化之后, 这个操作并不会开始(NSOperation 实例只有在调用 start 方法或者加入 NSOperationQueue 才会执行), 我们需要将这个操作加入到一个 NSOperationQueue 中.*/</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         创建SDWebImageDownLoaderOperation操作对象(下载的操作就是在SDWebImageDownLoaderOperation类里面进行的)</div><div class="line">         传入了进度回调,完成回调,取消回调</div><div class="line">         </div><div class="line">         @property (assign, nonatomic) Class operationClass;</div><div class="line">         将Class作为属性存储,初始化具体Class,使用的时候调用具体class的方法</div><div class="line">         */</div><div class="line"></div><div class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</div><div class="line">                                                             SDWebImageDownloader *sself = wself;</div><div class="line">                                                             <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                             __block <span class="built_in">NSArray</span> *callbacksForURL;</div><div class="line">                                                             <span class="comment">/**</span></div><div class="line">                                                              URLCallbacks是一个字典,key是url,value是一个数组,</div><div class="line">                                                              数组里面装的是字典,key是NSString代表着回调类型,value为block是对应的回调</div><div class="line">                                                              确保提交的block是指定队列中特定时段唯一在执行的一个.</div><div class="line">                                                              */</div><div class="line">                                                             </div><div class="line">                                                             <span class="built_in">dispatch_sync</span>(sself.barrierQueue, ^&#123;</div><div class="line">                                                                 <span class="comment">//根据key取出装了字典的数组</span></div><div class="line">                                                                 callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</div><div class="line">                                                             &#125;);</div><div class="line">                                                             </div><div class="line">                                                             <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                 <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                                     <span class="comment">//根据kProgressCallbackKey这个key取出进度的操作</span></div><div class="line">                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">                                                                     <span class="comment">//返回已经接收的数据字节,以及未接收的数据(预计字节)</span></div><div class="line">                                                                     <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);</div><div class="line">                                                                 &#125;);</div><div class="line">                                                             &#125;</div><div class="line">                                                         &#125;</div><div class="line">                                                        completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                            <span class="comment">//依旧是根据url这个key取出一个里面装了字典的数组</span></div><div class="line">                                                            __block <span class="built_in">NSArray</span> *callbacksForURL;</div><div class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</div><div class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</div><div class="line">                                                                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                                                                    <span class="comment">//如果这个任务已经完成,就根据url这个key从URLCallbacks字典里面删除</span></div><div class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                                &#125;</div><div class="line">                                                            &#125;);</div><div class="line">                                                            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                <span class="comment">//根据kCompletedCallbackKey这个key取出SDWebImageDownloaderCompletedBlock(完成的block)</span></div><div class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">                                                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">                                                            <span class="comment">//将url对应的所有回调移除</span></div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</div><div class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                            &#125;);</div><div class="line">                                                        &#125;];</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">//上面 是SDWebImageDownloaderOperation *operation的创建,从这里开始就都是对operation的配置</span></div><div class="line">        </div><div class="line">        <span class="comment">// 设置是否需要解压</span></div><div class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         用户认证 NSURLCredential</div><div class="line">         当连接客户端与服务端进行数据传输的时候,web服务器</div><div class="line">         收到客户端请求时可能需要先验证客户端是否是正常用户,再决定是否返回该接口的真实数据</div><div class="line">         </div><div class="line">         NSURLCredential 身份认证</div><div class="line">         </div><div class="line">         认证过程</div><div class="line">         1.web服务器接收到来自客户端的请求</div><div class="line">         2.web服务并不直接返回数据,而是要求客户端提供认证信息,也就是说挑战是服务端向客户端发起的</div><div class="line">         2.1要求客户端提供用户名与密码挑战 NSInternetPassword</div><div class="line">         2.2 要求客户端提供客户端证书 NSClientCertificate</div><div class="line">         2.3要求客户端信任该服务器</div><div class="line">         3.客户端回调执行,接收到需要提供认证信息,然后提供认证信息,并再次发送给web服务</div><div class="line">         4.web服务验证认证信息</div><div class="line">         4.1认证成功,将最终的数据结果发送给客户端</div><div class="line">         4.2认证失败,错误此次请求,返回错误码401</div><div class="line"></div><div class="line">         </div><div class="line">         iOS7.0之前使用的网络框架是NSURLConnection,在 2013 的 WWDC 上，</div><div class="line">         苹果推出了 NSURLConnection 的继任者：NSURLSession</div><div class="line">         </div><div class="line">         SDWebImage使用的是NSURLConnection,这两种网络框架的认证调用的方法也是不一样的,有兴趣的可以去google一下这里只看下NSURLConnection的认证(在这里写看着有些吃力,移步到这个代码框外面阅读)</div><div class="line">         </div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wself.urlCredential) &#123;</div><div class="line">            operation.credential = wself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:wself.username password:wself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//根据下载选项SDWebImageDownloaderHighPriority设置优先级</span></div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">//只有将operation加入到这个下载队列中, 这个操作才会执行.</span></div><div class="line">        <span class="comment">//将下载操作加到下载队列中</span></div><div class="line">        [wself.downloadQueue addOperation:operation];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            </div><div class="line">            <span class="comment">/**</span></div><div class="line">             根据executionOrder设置操作的依赖关系</div><div class="line">             executionOrder代表着下载操作执行的顺序,它是一个枚举</div><div class="line">             SD添加下载任务是同步的，而且都是在self.barrierQueue这个并行队列中，</div><div class="line">             同步添加任务。这样也保证了根据executionOrder设置依赖关是正确的。</div><div class="line">             换句话说如果创建下载任务不是使用dispatch_barrier_sync完成的，而是使用异步方法 ，虽然依次添加创建下载操作A、B、C的任务，但实际创建顺序可能为A、C、B，这样当executionOrder的值是SDWebImageDownloaderLIFOExecutionOrder，设置的操作依赖关系就变成了A依赖C，C依赖B</div><div class="line">             </div><div class="line">             typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line">             // 默认值，所有的下载操作以队列类型执行,先被加入下载队列的操作先执行</div><div class="line">             SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line">             // 所有的下载操作以栈类型执行,后进先出,后被加入下载队列的操作先执行</div><div class="line">             SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">             &#125;;</div><div class="line">             */</div><div class="line">            </div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</div><div class="line">    <span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     Serial 串行 Concurrent并发</div><div class="line">     任务串行执行每次只有一个任务执行</div><div class="line">     任务并发执行就是同一时间可以有多个任务被执行</div><div class="line">     </div><div class="line">     Synchronous 同步</div><div class="line">     一个同步函数只有在它完成预定的任务才返回(返回的意思是:返回当前线程,线程继续向下执行任务,你可以自己做个测试用一个同步函数,任务里面sleep(3);测试一下就明白了)</div><div class="line">     </div><div class="line">     Asynchronous 异步</div><div class="line">     一个异步函数,会立即返回,预定任务会完成,但是不会等到这个任务完成才返回</div><div class="line">     </div><div class="line">     Queues 队列</div><div class="line">     GCD提供 dispatch queues来处理代码,这些队列管理你提供给GCD的任务并用FIFO顺序执行,这保证了第一个被添加到队列里的任务会是队列中第一个执行的,第二个被添加的任务第二个开始执行,如此直到队列的终点</div><div class="line">     只能保证任务开始的顺序不能保证任务结束的顺序</div><div class="line">     </div><div class="line">     Serial Queues 串行队列</div><div class="line">     串行队列的任务一次执行一个,每一个任务只有在前一个任务完成的时候才开始,但是你不知道一个任务(block)和下一个开始之间的时间长度</div><div class="line">     </div><div class="line">     Concurrent Queues 并发队列</div><div class="line">     在并发队列中的任务能得到的保证是它们会被按照被添加的顺序开始执行,任务能以任意顺序完成,但是你不知道什么时候才开始运行下一个任务,或者任意时刻有多少block在运行,这完全取决于GCD</div><div class="line">     </div><div class="line">     Queue Type 队列类型</div><div class="line">     主队列(main queue),和其它串行队列一样,这个队列中的任务一次只能执行一个,然后它能保证所有的任务都在主线程执行,而主线程是唯一可用于更新UI的线程,这个队列就是用于发消息给UIView或发送通知的</div><div class="line">     </div><div class="line">     全局调度队列(Global Dispatch Queues),它分了四种优先级(任务执行的优先级):background , low , default , high</div><div class="line">     Apple的API也会使用这些队列,所以你添加的任何任务都不会是这些队列唯一的任务</div><div class="line">     </div><div class="line">     自己创建的串行队列 或者并发队列</div><div class="line">     </div><div class="line">     GCD提供的函数</div><div class="line">     dispatch_async 异步 , 与其他线程无关</div><div class="line">     dispatch_sync 同步,阻塞其他线程</div><div class="line">     dispatch_apply 重复执行</div><div class="line">     dispatch_after 延迟执行</div><div class="line">     dispatch_barrier_async dispatch_barrier_sync(下面细讲)</div><div class="line">     </div><div class="line">     GCD的使用呢,总结起来就是先选用一个GCD提供的函数,传入一个你要调用的队列(三种队列类型的一种)和一个block(任务),</div><div class="line">     队列会在轮到这个block执行的时候执行这个block</div><div class="line">     </div><div class="line">     注意:队列是用来存放任务的,队列并不等于线程,队列中存放的任务最后都要由线程来执行</div><div class="line">     </div><div class="line">     */</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     再回到刚才要看的部分,dispatch_barrier_sync是我们选用的GCD提供的函数,self.barrierQueue是存放任务的队列,block里面是要执行的任务</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     先来看看dispatch_barrier_sync</div><div class="line">     Dispatch Barrier解决多线程并发读写一个资源发生死锁</div><div class="line">     sync说明了这是个同步函数,任务不会立即返回,会等到任务执行结束才返回</div><div class="line">     使用dispatch_barrier_sync此函数创建的任务会首先去查看队列中有没有别的任务要执行,如果有则会等待已有任务执行完毕再执行;同时在此方法后添加的任务必须等到此方法中任务执行后才能执行,利用这个方法可以控制执行顺序</div><div class="line">     Dispatch   Barrier确保提交的block是指定队列中特定时段唯一在执行的一个.在所有先于Dispatch Barrier的任务都完成的情况下这个block才开始执行.轮到这个block时barrier会执行这个block并且确保队列在此过程 不会执行其他任务.block完成后才恢复队列</div><div class="line">     */</div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         这是用户自己创建的队列,DISPATCH_QUEUE_CONCURRENT代表的是它是一个并行队列,为什么选择并发队列而不是串行队列我们来想一下:</div><div class="line">         串行队列可以保证任务按照添加的顺序一个个开始执行,并且上一个任务结束才开始下一个任务,这已经可以保证任务的执行顺序(或者说是任务结束的顺利)了,但是并行队列不一样,并发队列只能保证任务的开始,至于任务以什么样的顺序结束并不能保证但是并发队列使用Barrier却是可以保证的.</div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="comment">// 多线程并发开始，同步返回，这样的好处是减少多任务执行的时间</span></div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         URLCallbacks是一个可变字典,key是NSURL类型,value为NSMutableArray类型,value(数组里面)只包含一个元素,这个元素的类型是NSMutableDictionary类型,这个字典的key为NSString类型代表着回调类型,value为block,是对应的回调</div><div class="line">         这些代码的目的都是为了给url绑定回调</div><div class="line">         */</div><div class="line">        <span class="comment">/* 如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first 不为 YES 那么 HTTP 请求就不会被初始化, 图片也无法被获取.*/</span></div><div class="line">        <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</div><div class="line">            <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">            first = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Handle single download of simultaneous download request for the same URL</span></div><div class="line">        <span class="comment">// 然后, 在这个方法中会重新修正在 URLCallbacks 中存储的回调块.</span></div><div class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">        [callbacksForURL addObject:callbacks];</div><div class="line">        <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</div><div class="line">        </div><div class="line"></div><div class="line">        <span class="comment">/* 如果是第一次添加回调块, 那么就会直接运行这个 createCallback 这个 block, 而这个 block, 就是我们在前一个方法 downloadImageWithURL:options:progress:completed: 中传入的回调块.*/</span></div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         如果url第一次绑定它的回调,也就是第一次使用这个url创建下载任务则执行一次创建回调</div><div class="line">         在创建回调中 创建下载操作(下载操作并不是在这里创建的),dispatch_barrier_sync执行确保同一时间只有一个线程操作URLCallbacks属性,也就是确保了下面创建过程中在给operation传递回调的时候能取到正确的self.URLCallbacks[url]值,同事确保后面有相同的url再次创建的时候if (!self.URLCallbacks[url])分支不再进入,first==NO,也就不再继续调用创建回调,这样就确保了同一个url对应的图片不会重复下载</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (first) &#123;</div><div class="line">            createCallback();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">// 以上这部分代码总结起来只做了一件事情:在barrierQueue队列中创建下载任务</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中，-这个类就是处理-HTTP-请求-URL-连接的类-当这个类的实例被加入队列之后-start-方法就会被调用-而-start-方法首先就会产生一个-NSURLConnection"><a href="#当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中，-这个类就是处理-HTTP-请求-URL-连接的类-当这个类的实例被加入队列之后-start-方法就会被调用-而-start-方法首先就会产生一个-NSURLConnection" class="headerlink" title="当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中， 这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection."></a>当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中， 这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection.</h3><p>下面我们看一下start方法的实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*但是下面这个方法- (void)start就是关键了,它是对NSOperation- (void)start的重写,这个方法是执行下载任务的核心代码*/</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//先加一把线程锁,保证执行到这里的时候只有当前线程在执行下面的方法</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//如果下载操作被取消了</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            <span class="comment">//把下载相关的属性置为nil</span></div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         App 进入后台时,请求继续执行一段时间的方法,</div><div class="line">         使用UIApplication的beginBackgroundTaskWithExpirationHandler方法向系统借用一点时间，</div><div class="line">         继续执行下面的代码来完成connection的创建和进行下载任务。</div><div class="line">         */</div><div class="line">        </div><div class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sself) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">/**在后台任务执行时间超过最大时间时，</span></div><div class="line">                     也就是后台任务过期执行过期回调。</div><div class="line">                     在回调主动将这个后台任务结束。</div><div class="line">                     */</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">        <span class="comment">// 下载任务执行的状态,在执行是YES,不在执行时NO</span></div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">        <span class="comment">// //创建用于下载的connection 实例化connection</span></div><div class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</div><div class="line">        <span class="comment">//获取当前得得线程</span></div><div class="line">        <span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// connection 开始运行开始下载</span></div><div class="line">    [<span class="keyword">self</span>.connection start];<span class="comment">//在 start 方法调用之后, 就是 NSURLConnectionDataDelegate 中代理方法的调用.</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection) &#123;</div><div class="line">        <span class="comment">//任务开始立刻执行一次进度的回调</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 它会发出一个 SDWebImageDownloadStartNotification 通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//发送开始下载的通知</span></div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         在 [self.connection start];有返回结果(正常完成,有错误都算是结果)之前,</div><div class="line">         代码会一直阻塞在CFRunLoopRun()或者CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false) 这里,</div><div class="line">         也就是说  [self.connection start];之后下载就一直在进行中,一直到下载完成或者出错了(这两种情况都会调用CFRunLoopStop),这个阻塞才会解除</div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (floor(<span class="built_in">NSFoundationVersionNumber</span>) &lt;= <span class="built_in">NSFoundationVersionNumber_iOS_5_1</span>) &#123;</div><div class="line">            <span class="comment">// Make sure to run the runloop in our background thread so it can process downloaded data</span></div><div class="line">            <span class="comment">// Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span></div><div class="line">            <span class="comment">//       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span></div><div class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CFRunLoopRun</span>();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         <span class="comment">//如果图片非正常的下载完成</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) &#123;</div><div class="line">            <span class="comment">//取消下载请求连接</span></div><div class="line">            [<span class="keyword">self</span>.connection cancel];</div><div class="line">            </div><div class="line">            <span class="comment">/**</span></div><div class="line">             NSURLConnectionDelegate代理方法</div><div class="line">             主动调用,并制造一个错误,这个方法一旦被调用</div><div class="line">             代理就不会再接收connection的消息,也就是不在调用其他的任何代理方法,connection彻底结束</div><div class="line">             */</div><div class="line">            </div><div class="line">            [<span class="keyword">self</span> connection:<span class="keyword">self</span>.connection didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@&#123;<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span>.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果connection创建失败,这里直接执行完成回调,并传递一个connection没有初始化的错误</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//执行到这里说明下载操作已经完成了(无论是成功还是错误),所以要停止在后台的执行,使用endBackgroundTask:</span></div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行start之后下载操作正式开始，然后会回调NSURLConnectionDelegate里面一些方法，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在图片下载完成之后调用 completionBlock 来完成最后 UIImageView.image 的更新.</span></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)aConnection &#123;</div><div class="line">    </div><div class="line">    SDWebImageDownloaderCompletedBlock completionBlock = <span class="keyword">self</span>.completedBlock;</div><div class="line">    </div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         停止当前的runLoop,将connection属性和thread属性</div><div class="line">         发送下载停止的通知</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</div><div class="line">        <span class="keyword">self</span>.thread = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     检查sharedURLCache是否缓存了这次下载response</div><div class="line">     如果没有就把responseFromCached设置为NO</div><div class="line">     </div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (![[<span class="built_in">NSURLCache</span> sharedURLCache] cachedResponseForRequest:_request]) &#123;</div><div class="line">        responseFromCached = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     图片的缓存用的都是SDWebCache,所以就算设置了SDWebImageDownloaderIgnoreCachedResponse,</div><div class="line">     responseFromCached</div><div class="line">     回调的图片也是nil(理解有可能有偏差)</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) &#123;</div><div class="line">            completionBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">YES</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.imageData) &#123;</div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:<span class="keyword">self</span>.imageData];</div><div class="line">            <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">            image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">            </div><div class="line">            <span class="comment">// Do not force decoding animated GIFs // 注意对于gif图片,不需要解压缩</span></div><div class="line">            <span class="keyword">if</span> (!image.images) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//如果图片的大小为0 , 完成回调报错</span></div><div class="line">            <span class="keyword">if</span> (<span class="built_in">CGSizeEqualToSize</span>(image.size, <span class="built_in">CGSizeZero</span>)) &#123;</div><div class="line">                completionBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Downloaded image has 0 pixels"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//回调图片 已经图片的大小 完成状态YES</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                completionBlock(image, <span class="keyword">self</span>.imageData, <span class="literal">nil</span>, <span class="literal">YES</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//图片为空 回调 报错</span></div><div class="line">            completionBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Image data is nil"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.completionBlock = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将NSConnection 设置为完成状态</span></div><div class="line">    [<span class="keyword">self</span> done];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 会不停回调 progressBlock 来提示下载的进度.</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//'304 Not Modified' is an exceptional one</span></div><div class="line">    <span class="comment">//如果statusCode&lt;400并且不等304</span></div><div class="line">    <span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) &#123;</div><div class="line">        </div><div class="line">         <span class="comment">//设置文件的预期大小,如果response.expectedContentLength &gt;0那么预期文件的大小就是response.expectedContentLength ,反之就是0</span></div><div class="line">        <span class="built_in">NSInteger</span> expected = response.expectedContentLength &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response.expectedContentLength : <span class="number">0</span>;</div><div class="line">        <span class="keyword">self</span>.expectedSize = expected;</div><div class="line">        <span class="comment">//立即完成一次进度回调</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, expected);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//初始化属性imageDate,用于拼接图片 二进制数据</span></div><div class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];</div><div class="line">        <span class="keyword">self</span>.response = response;</div><div class="line">        </div><div class="line">        <span class="comment">//异步的 向主队队列发送一个通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];</div><div class="line">        </div><div class="line">        <span class="comment">//This is the case when server returns '304 Not Modified'. It means that remote image is not changed.</span></div><div class="line">        <span class="comment">//In case of 304 we need just cancel the operation and return cached image from the cache.</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         如果 statusCode == 304 就调用[self cancelInternal]方法 ,或者取消self.connection的连接</div><div class="line">         取消操作,发送操作停止的通知,执行完成回调,停止当前的runloop,设置下载完成标记为YES,正在执行的为NO,将属性置为空</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">304</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> cancelInternal];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span>.connection cancel];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 会不停回调 progressBlock 来提示下载的进度.</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">        <span class="comment">// The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/</span></div><div class="line">        <span class="comment">// Thanks to the author @Nyx0uf</span></div><div class="line"></div><div class="line">        <span class="comment">// Get the total bytes downloaded</span></div><div class="line">        <span class="comment">// 根据self.imageData获取已接收的数据的长度</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</div><div class="line"></div><div class="line">        <span class="comment">// Update the data source, we must pass ALL the data, not just the new bytes</span></div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         每次接收到数据时,都会用现有的数据创建一个CGImageSourceRef对象以做处理,</div><div class="line">         而且这个数据应该是已接收的全部数据,而不仅仅是新的字节,所以才使用self.imageData作为参数(注意创建imageSource使用的数据是CoreFoundation的data,但是self.imageData是NSData,所以用(__bridge CFDataRef)self.imageData做转化 )</div><div class="line">         */</div><div class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         在首次接收到数据的时候,图片的长宽都是0(width+height == 0)</div><div class="line">         先从这些包含图像信息的数据中取出图像的长,宽,方向等信息以备使用</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//获取图片的属性信息</span></div><div class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">if</span> (properties) &#123;</div><div class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</div><div class="line">                <span class="comment">//图片像素的高度 可以前面加(__bridge NSNumber *)转换为NSNumber类型</span></div><div class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</div><div class="line">                <span class="comment">//获取图片的宽度</span></div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;width);</div><div class="line">                <span class="comment">//获取图片的朝向</span></div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">                <span class="comment">//CoreFoundation对象类型不在ARC范围内,需要手动释放资源</span></div><div class="line">                <span class="built_in">CFRelease</span>(properties);</div><div class="line"></div><div class="line">                <span class="comment">// When we draw to Core Graphics, we lose orientation information,</span></div><div class="line">                <span class="comment">// which means the image below born of initWithCGIImage will be</span></div><div class="line">                <span class="comment">// oriented incorrectly sometimes. (Unlike the image born of initWithData</span></div><div class="line">                <span class="comment">// in connectionDidFinishLoading.) So save it here and pass it on later.</span></div><div class="line">                </div><div class="line">                <span class="comment">/**</span></div><div class="line">                 使用Core Craphics框架绘制image时,使用的是</div><div class="line">                 initWithCGImage这个函数,但是使用这个函数有时候会造成图片朝向的错误,</div><div class="line">                 所以在这里保存朝向信息,orientation是一个可以记录图片方向的枚举</div><div class="line">                 */</div><div class="line">                </div><div class="line">                orientation = [[<span class="keyword">self</span> <span class="keyword">class</span>] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         width+height&gt;0 说明这时候已经接收到图片的数据了</div><div class="line">         totalSize &lt; self.expectedSize 说明图片 还没有接收完全</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</div><div class="line">            <span class="comment">// Create the image</span></div><div class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="meta">#ifdef TARGET_OS_IPHONE</span></div><div class="line">            <span class="comment">// Workaround for iOS anamorphic image 失真的变形的图片</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</div><div class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">                <span class="keyword">if</span> (bmContext) &#123;</div><div class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</div><div class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="literal">nil</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    image = scaledImage;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">                        <span class="keyword">self</span>.completedBlock(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">CFRelease</span>(imageSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/22/SDWebImage源码分析_02/" data-id="cir1zqqns00067p5hnr60yutb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/22/hello-world/" class="article-date">
  <time datetime="2016-07-22T02:03:11.000Z" itemprop="datePublished">2016-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/22/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/22/hello-world/" data-id="cir1zqqnm00047p5h23akitjl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDWebImage源码分析-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/12/SDWebImage源码分析-01/" class="article-date">
  <time datetime="2016-07-12T12:59:24.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/12/SDWebImage源码分析-01/">SDWebImage源码分析_01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天我们正式进入源代码的分析，在上一章的简介中我们讲到这个框架主要以UIImageView和UIButton的category为入口，我们已UIImageView为例，逐行分一下一下整个加载流程。</p>
<h3 id="首先我们看一下UIImageView-WebCache-h这个入口类："><a href="#首先我们看一下UIImageView-WebCache-h这个入口类：" class="headerlink" title="首先我们看一下UIImageView+WebCache.h这个入口类："></a>首先我们看一下UIImageView+WebCache.h这个入口类：</h3><p>首先这个类提供了下面这个枚举，代表了图片的加载方式，其中各个选项的含义注释写的很清楚，我们直接往下面看：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line"></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,     失败后重载，默认关闭</div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,     低优先级，默认关闭。打开后当scrollview滑动时延迟加载</div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, 	只有内存缓存，没有磁盘缓存</div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>，  打开边加载边显示图片，默认关闭</div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  刷新缓存 将硬盘缓存交给系统自带的<span class="built_in">NSURLCache</span>去处理</div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,   后台加载</div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   通过设置<span class="built_in">NSMutableURLRequest</span>.HTTPShouldHandleCookies = <span class="literal">YES</span>来处理存储在<span class="built_in">NSHTTPCookieStore</span>中的cookie</div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,   允许不受信任的SSL证书。主要用于测试目的。</div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   改变队列提高下载优先级</div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   延迟显示占位图，等图片加载完</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * We usually don't call transformDownloadedImage delegate method on animated images,</div><div class="line">     * as most transformation code would mangle it.</div><div class="line">     * Use this flag to transform them anyway.</div><div class="line">     */</div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * By default, image is added to the imageView after download. But in some cases, we want to</div><div class="line">     * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance)</div><div class="line">     * Use this flag if you want to manually set the image in the completion when success</div><div class="line">     */</div><div class="line">    SDWebImageAvoidAutoSetImage = <span class="number">1</span> &lt;&lt; <span class="number">11</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>根据参数不同，提供了一些列方法，最终都会调用下面这个方法，这里涉及到代码复用的设计思想。大概的思路是：首先当一个UIImageView调用下面这个方法加载图片时，先取消UIImageView当前绑定的操作，然后把URL绑定到UIImageView上，接着显示占位图和loading指示器，然后调用下载方法，完成之后绑定操作。具体看注释：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/* 取消正在下载的操作 */</span></div><div class="line">    <span class="comment">/* 移除UIImageView当前绑定的操作.当TableView的cell包含的UIImageView被重用的时候首先执行这一行代码,保证这个ImageView的下载和缓存组合操作都被取消*/</span></div><div class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</div><div class="line">    </div><div class="line">    <span class="comment">/* 关联view对应的图片URL*/</span></div><div class="line">    <span class="comment">//将 url作为属性绑定到ImageView上,用static char imageURLKey作key</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"></div><div class="line">    <span class="comment">/* 显示备用图片*/</span></div><div class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/* 确保在主线程中操作*/</span></div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.image = placeholder;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="comment">// check if activityView is enabled or not</span></div><div class="line">        <span class="comment">// 检查是否通过`setShowActivityIndicatorView:`方法设置了显示正在加载指示器。如果设置了，使用`addActivityIndicator`方法向self添加指示器</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> showActivityIndicatorView]) &#123;</div><div class="line">            [<span class="keyword">self</span> addActivityIndicator];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//下载的核心方法</span></div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//移除加载指示器</span></div><div class="line">            [wself removeActivityIndicator];</div><div class="line">            </div><div class="line">            <span class="comment">//如果imageView不存在了就return停止操作</span></div><div class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">            </div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">                </div><div class="line">                <span class="comment">/*</span></div><div class="line">                 SDWebImageAvoidAutoSetImage,默认情况下图片会在下载完毕后自动添加给imageView,但是有些时候我们想在设置图片之前加一些图片的处理,就要下载成功后去手动设置图片了,不会执行`wself.image = image;`,而是直接执行完成回调，有用户自己决定如何处理。</div><div class="line">                 */</div><div class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</div><div class="line">                &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">/*</span></div><div class="line">                 如果后两个条件中至少有一个不满足，那么就直接将image赋给当前的imageView</div><div class="line">                 ，并调用setNeedsLayout</div><div class="line">                  */</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                    wself.image = image;</div><div class="line">                    [wself setNeedsLayout];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">/*</span></div><div class="line">                     image为空，并且设置了延迟设置占位图，会将占位图设置为最终的image，，并将其标记为需要重新布局。</div><div class="line">                     */</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        wself.image = placeholder;</div><div class="line">                        [wself setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">        <span class="comment">/* 把operation添加的view的operationDictionary中，关联对象*/</span></div><div class="line">         <span class="comment">// 为UIImageView绑定新的操作,因为之前把ImageView的操作cancel了</span></div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 判断url不存在，移除加载指示器，执行完成回调，传递错误信息。</span></div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            </div><div class="line">            [<span class="keyword">self</span> removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="接下来我们看一下UIView-WebCacheOperation-h-这个类，他的主要作用是给视图绑定操作，因为是分类，所以通过关联对象的方式设置属性。"><a href="#接下来我们看一下UIView-WebCacheOperation-h-这个类，他的主要作用是给视图绑定操作，因为是分类，所以通过关联对象的方式设置属性。" class="headerlink" title="接下来我们看一下UIView+WebCacheOperation.h 这个类，他的主要作用是给视图绑定操作，因为是分类，所以通过关联对象的方式设置属性。"></a>接下来我们看一下UIView+WebCacheOperation.h 这个类，他的主要作用是给视图绑定操作，因为是分类，所以通过关联对象的方式设置属性。</h3><blockquote>
<p>框架中的所有操作实际上都是通过一个 operationDictionary 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性, 至于为什么添加到 UIView 上, 主要是因为这个  operationDictionary 需要在 UIButton 和 UIImageView 上重用, 所以需要添加到它们的根类上.</p>
</blockquote>
<p>上面我们提到的取消UIImageView的操作即是下面这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// Cancel in progress downloader from queue</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</div><div class="line">    <span class="comment">//如果 operationDictionary可以取到,根据key可以得到与视图相关的操作,取消他们,并根据key值,从operationDictionary里面删除这些操作</span></div><div class="line">    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];</div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</div><div class="line">                <span class="keyword">if</span> (operation) &#123;</div><div class="line">                    [operation cancel];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</div><div class="line">            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</div><div class="line">        &#125;</div><div class="line">        [operationDictionary removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如上面代码实际上，视图会在运行时关联一个dictionary对象，用来存储下载操作的operation，每次下载图片之前会把之前的操作取消，并且从dictionary中移除。下面这个方法</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">     这个loadOperationKey 的定义是:static char loadOperationKey;</div><div class="line">     它对应的绑定在UIView的属性是operationDictionary(NSMutableDictionary类型)</div><div class="line">     operationDictionary的value是操作,key是针对不同类型视图和不同类型的操作设定的字符串</div><div class="line">     注意:&amp;是一元运算符结果是右操作对象的地址(&amp;loadOperationKey返回static char loadOperationKey的地址)</div><div class="line">     */</div><div class="line">     </div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> loadOperationKey;</div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)operationDictionary &#123;</div><div class="line">    <span class="comment">/* 获取关联对象*/</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="comment">//如果可以查到operations,就rerun,反之给视图绑定一个新的,空的operations字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;</div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="comment">/* 设置关联对象*/</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="我们再来看一下最核心的类SDWebImageManager，这个是整个框架的处理核心，这里包涵SDImageCache和SDWebImageDownloader两个属性，分别代表缓存机制和下载机制，可以说这个管理类是一个中转站"><a href="#我们再来看一下最核心的类SDWebImageManager，这个是整个框架的处理核心，这里包涵SDImageCache和SDWebImageDownloader两个属性，分别代表缓存机制和下载机制，可以说这个管理类是一个中转站" class="headerlink" title="我们再来看一下最核心的类SDWebImageManager，这个是整个框架的处理核心，这里包涵SDImageCache和SDWebImageDownloader两个属性，分别代表缓存机制和下载机制，可以说这个管理类是一个中转站."></a>我们再来看一下最核心的类SDWebImageManager，这个是整个框架的处理核心，这里包涵SDImageCache和SDWebImageDownloader两个属性，分别代表缓存机制和下载机制，可以说这个管理类是一个中转站.</h3><blockquote>
<p>首先我们来看一下下面的这个方法，他主要完成了这些事儿。</p>
<p>1.创建一个组合Operation，是一个SDWebImageCombinedOperation对象，这个对象负责对下载operation创建和管理，同时有缓存功能，是对下载和缓存两个过程的组合。</p>
<p>2.先去寻找这张图片 内存缓存和磁盘缓存，这两个功能在self.imageCache的queryDiskCacheForKey: done:方法中完成，这个方法的返回值既是一个缓存operation，最终被赋给上面的Operation的cacheOperation属性。在查找缓存的完成回调中的代码是重点：它会根据是否设置了SDWebImageRefreshCached选项和代理是否支持下载决定是否要进行下载，并对下载过程中遇到NSURLCache的情况做处理，还有下载失败的处理以及下载之后进行缓存，然后查看是否设置了形变选项并调用代理的形变方法进行对图片形变处理。</p>
<p>3.将上面的下载方法返回的操作命名为subOperation，并在组合操作operation的cancelBlock代码块中添加对subOperation的cancel方法的调用。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></div><div class="line">    <span class="built_in">NSAssert</span>(completedBlock != <span class="literal">nil</span>, <span class="string">@"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won't</span></div><div class="line">    <span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></div><div class="line">    <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></div><div class="line">    <span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</div><div class="line">        url = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">/* 这里仅仅是将这个 SDWebImageOperation 类包装成一个看着像 NSOperation 其实并不是 NSOperation 的类, 而这个类唯一与 NSOperation 的相同之处就是它们都可以响应 cancel 方法.</span></div><div class="line">     而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 cancel 方法, 会使得它持有的两个 operation 都被 cancel.</div><div class="line">     而这个类, 应该是为了实现更简洁的 cancel 操作而设计出来的.</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="comment">/*首先我们先来看看__block和__weak的区别</span></div><div class="line">     </div><div class="line">     __block用于指明当前声明的变量在被block捕获之后，可以在block中改变变量的值。因为在block声明的同时会截获该block所使用的全部自动变量的值，这些值只在block中只有"使用权"而不具有"修改权"。</div><div class="line">     而block说明符就为block提供了变量的修改权，**block不能避免循环引用**，这就需要我们在 block 内部将要退出的时候手动释放掉 blockObj,blockObj = nil</div><div class="line">     </div><div class="line">     __weak是所有权修饰符,__weak本身是可以避免循环引用的问题的,但是其会导致外部对象释放之后,block内部也访问不到对象的问题,</div><div class="line">     我们可以通过在block内部声明一个__strong的变量来指向weakObj,使外部既能在block内部保持住又能避免循环引用*/</div><div class="line">    </div><div class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    __<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//@synchronized是OC中一种方便地创建互斥锁的方式--它可以防止不同线程在同一时间执行区块的代码</span></div><div class="line">    </div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/*self.failedURLs是一个NSSet类型的集合,里面存放的都是下载失败的图片的url,failedURLs不是NSArray类型的原因是:</span></div><div class="line">         </div><div class="line">         在搜索一个个元素的时候NSSet比NSArray效率高,主要是它用到了一个算法hash(散列,哈希) ,比如你要存储A,一个hash算法直接就能找到A应该存储的位置;</div><div class="line">         同样当你要访问A的时候,一个hash过程就能找到A存储的位置,对于NSArray,若想知道A到底在不在数组中,则需要遍历整个数据,显然效率较低了</div><div class="line">         </div><div class="line">         并且NSSet里面不含有重复的元素,同一个下载失败的url只会存在一个*/</div><div class="line">        </div><div class="line">        <span class="comment">//判断这个url是否是fail过的,如果url failed过的那么isFailedUrl就是true.</span></div><div class="line">        isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果url为空，或者不是：加载失败重试模式下&amp;&amp;当前已经加载失败，直接返回</span></div><div class="line">    <span class="comment">//!(options &amp; SDWebImageRetryFailed) 之前就提过一个类似的了,它的意思看这个options是不是和SDWebImageRetryFailed不相同</span></div><div class="line">    <span class="comment">//如果不相同并且isFailedUrl是true.那么就回调一个error的block</span></div><div class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">        dispatch_main_sync_safe(^&#123;</div><div class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</div><div class="line">            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed))</div><div class="line">    &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 把operation加入到self.runningOperations的数组里面,并创建一个互斥线程锁来保护这个操作</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*既然我们获取了 url, 再通过 url 获取对应的 key*/</span></div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"></div><div class="line">    <span class="comment">/*这里调用 SDImageCache 的实例方法 queryDiskCacheForKey:done: 来尝试在缓存中获取图片的数据. 而这个方法返回的就是货真价实的 NSOperation.*/</span></div><div class="line">    <span class="comment">// 是SDImageCache的一个方法,根据图片的key,异步查询磁盘缓存的方法</span></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/* 如果任务被取消了，从队列中删除这个任务*/</span></div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/* 如果缓存里面没有图片，或者加载方式为刷新缓存并且实现了对应的代理方法*/</span></div><div class="line">        </div><div class="line">        <span class="comment">//条件1:在缓存中没有找到图片或者options选项里面包含了SDWebImageRefreshCached(这两项都需要进行请求网络图片的)</span></div><div class="line">        <span class="comment">//条件2:代理允许下载,SDWebImageManagerDelegate的delegate不能响应imageManager:shouldDownloadImageForURL:方法或者能响应方法且方法返回值为YES.</span></div><div class="line">        也就是没有实现这个方法就是允许的,如果实现了的话,返回<span class="literal">YES</span>才是允许</div><div class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line">            </div><div class="line"></div><div class="line">            <span class="comment">//如果在缓存中找到了image且options选项包含SDWebImageRefreshCached,先在主线程完成一次回调,使用的是缓存中找的图片</span></div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></div><div class="line">                    <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></div><div class="line">                    <span class="comment">// 如果在缓存中找到了image但是设置了SDWebImageRefreshCached选项，传递缓存的image，同时尝试重新下载它来让NSURLCache有机会接收服务器端的更新</span></div><div class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></div><div class="line">            <span class="comment">// 如果没有在缓存中找到image 或者设置了需要请求服务器刷新的选项,则仍需要下载</span></div><div class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></div><div class="line">                <span class="comment">// 如果image已经被缓存但是设置了需要请求服务器刷新的选项，强制关闭渐进式选项</span></div><div class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;<span class="comment">// ~取反</span></div><div class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></div><div class="line">                <span class="comment">// 如果image已经被缓存但是设置了需要请求服务器刷新的选项，忽略从NSURLCache读取的image</span></div><div class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="comment">//创建下载操作,先使用self.imageDownloader下载</span></div><div class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url</div><div class="line">             options:downloaderOptions</div><div class="line">             progress:progressBlock</div><div class="line">            completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 在block里面强引用block外面定义的弱引用对象，是为了防止弱引用对象在外部被烧毁后block里面也随之销毁了</span></div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                </div><div class="line">                </div><div class="line">                <span class="comment">/* 如果任务销毁了，或者任务被取消了 do noting*/</span></div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//如果操作取消了,不做任何事情</span></div><div class="line">                    <span class="comment">//如果我们调用completedBlock,这个block会和另外一个completedBlock争夺一个对象,因此这个block被调用后会覆盖新的数据</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">/* 有错误信息，直接返回*/</span></div><div class="line">                    dispatch_main_sync_safe(^&#123;</div><div class="line">                        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, finished, url);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line"></div><div class="line">                    <span class="comment">/* 失败后，将url添加到失败数组中*/</span></div><div class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">/* 正常下载完图片，如果是失败之后重试的模式，需要把url从失败的数组中清除，这里如果没有失败过failedURLs里面没有url，不过没问题*/</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">/* 判断有没有磁盘缓存*/</span></div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line"></div><div class="line">                    <span class="comment">//options包含了SDWebImageRefreshCached选项,且缓存中找到了image且没有下载成功</span></div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">                        <span class="comment">// 图片刷新遇到了NSSURLCache中有缓存的状况，不调用完成回调。</span></div><div class="line">                    &#125;</div><div class="line">                     <span class="comment">//图片下载成功并且 设置了需要变形Image的选项且变形的代理方法已经实现</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; </div><div class="line">                    (!downloadedImage.images || </div><div class="line">                    (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; </div><div class="line">                    [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//全局队列异步执行</span></div><div class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                            </div><div class="line">                            <span class="comment">// 在图片下载完之后，先调用这个代理，用户可以实现这个代理对图片进行transform操作，然后将处理之后图片返回来</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="comment">//对已经transform的图片进行缓存</span></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                </div><div class="line">                                <span class="comment">/* 如果这个方法返回了正确的 downloadedImage, 那么我们就会在全局的缓存中存储这个图片的数据*/</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? <span class="literal">nil</span> : data) forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="comment">//主线程执行完成回调</span></div><div class="line">                            <span class="comment">/* 调用 completedBlock 对 UIImageView 或者 UIButton 添加图片, 或者进行其它的操作.*/</span></div><div class="line">                            dispatch_main_sync_safe(^&#123;</div><div class="line">                                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                    completedBlock(transformedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                                &#125;</div><div class="line">                            &#125;);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//如果没有图片transform的需求并且图片下载完成且图片存在就直接缓存</span></div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        dispatch_main_sync_safe(^&#123;</div><div class="line">                            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">/* 任务结束之后从任务队列中清楚该任务*/</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    <span class="comment">// 从正在进行的操作列表中移除这组合操作</span></div><div class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                        <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">                            [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="comment">/*最后, 我们将这个 subOperation 的 cancel 操作添加到 operation.cancelBlock 中. 方便操作的取消.*/</span></div><div class="line">            <span class="comment">//设置组合操作取消得得回调</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [subOperation cancel];</div><div class="line">                </div><div class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                    <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">                        [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/*如果我们在缓存中查找到了对应的图片, 那么我们直接调用 completedBlock 回调块结束这一次的图片下载操作*/</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Image not in cache and download disallowed by delegate</span></div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/12/SDWebImage源码分析-01/" data-id="cir1zqqnl00037p5hf23jkgck" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SDWebImage-简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/11/SDWebImage-简介/" class="article-date">
  <time datetime="2016-07-11T05:23:35.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/SDWebImage-简介/">SDWebImage 简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul>
<li>作用：一个异步下载图片并且支持缓存的UIImageView分类。</li>
<li>机制：UIImageView+WebCache 和 UIButton+WebCache 直接为表层的 UIKit 框架提供接口, 而 SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.</li>
<li>流程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">查找缓存 </div><div class="line">1.内存中查找 Y：返回图片更新视图 N：下一步</div><div class="line">2.磁盘中查找 Y：返回图片更新视图 N：下一步 </div><div class="line">异步下载图片--&gt;加入缓存--&gt;更新视图</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>这个框架通过category提供了非常简洁的入口，使用时只需调用sd_setImageWithURL这几个方法即可</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">   <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</div><div class="line"></div><div class="line">   <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</div><div class="line">       cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:MyIdentifier]</div><div class="line">                autorelease];</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// Here we use the provided sd_setImageWithURL: method to load the web image</span></div><div class="line">   <span class="comment">// Ensure you use a placeholder image otherwise cells will be initialized with no image</span></div><div class="line">   [cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/image.jpg"</span>]</div><div class="line">                     placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>]];</div><div class="line"></div><div class="line">   cell.textLabel.text = <span class="string">@"My Text"</span>;</div><div class="line">   <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ps： 第一次正式使用github发表文章，内容有点水，接下来会分几篇文章来分享SDWebimage开源库，主要从源码阅读、源码设计到的基础知识、涉及到的设计模式开发技巧等方面逐步分析。</p>
<hr>
<p>2017-07-13 晚</p>
<p>看了几天源码，发现有很多基础知识不太清楚，觉得有必要在分析源码之前把涉及到的基础知识回顾总结一下：</p>
<h3 id="1-NS-ENUM和NS-OPTIONS"><a href="#1-NS-ENUM和NS-OPTIONS" class="headerlink" title="1.NS_ENUM和NS_OPTIONS"></a>1.NS_ENUM和NS_OPTIONS</h3><p>NS_ENUM 通过十进制整型判断；NS_OPTIONS通过二进制为运算判断。一般情况下我们的枚举类型用NS_ENUM就够了，但是在有些业务中判断包含某种选项，或者为了不同选项之间的组合，使用NS_OPTIONS可以完美解决。我们看下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123; </div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">//0001</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">//0010</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 0100</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">//1000</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(options &amp; SDWebImageRetryFailed)&#123;xxx1&#125;</div><div class="line"><span class="keyword">if</span>(options &amp; SDWebImageLowPriority)&#123;xx1x&#125;</div><div class="line"><span class="keyword">if</span>(options &amp; SDWebImageCacheMemoryOnly)&#123;x1xx&#125;</div><div class="line"><span class="keyword">if</span>(options &amp; SDWebImageProgressiveDownload)&#123;<span class="number">1</span>xxx&#125;</div></pre></td></tr></table></figure>
<h3 id="2-objc-setAssociatedObject和objc-getAssociatedObject-–-gt-RunTime"><a href="#2-objc-setAssociatedObject和objc-getAssociatedObject-–-gt-RunTime" class="headerlink" title="2.objc_setAssociatedObject和objc_getAssociatedObject –&gt; RunTime"></a>2.objc_setAssociatedObject和objc_getAssociatedObject –&gt; RunTime</h3><p>这一对方法是运行时方法，作用是给对象动态添加关联对象，关联对象我们可以理解为运行时添加的属性，这个属性值的set和get方法即为这两个方法。因为category无法直接添加属性，而很多情况下我们需要使用category里面的属性，这时候我们可以通过关联对象的方式变相添加，例如下面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> loadOperationKey;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">WebCacheOperation</span>)</span></div><div class="line"></div><div class="line"><span class="comment">/*框架中的所有操作实际上都是通过一个 operationDictionary 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性, 至于为什么添加到 UIView 上, 主要是因为这个  operationDictionary 需要在 UIButton 和 UIImageView 上重用, 所以需要添加到它们的根类上.*/</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)operationDictionary &#123;</div><div class="line">    <span class="comment">/* 获取关联对象*/</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     这个loadOperationKey 的定义是:static char loadOperationKey;</div><div class="line">     它对应的绑定在UIView的属性是operationDictionary(NSMutableDictionary类型)</div><div class="line">     operationDictionary的value是操作,key是针对不同类型视图和不同类型的操作设定的字符串</div><div class="line">     注意:&amp;是一元运算符结果是右操作对象的地址(&amp;loadOperationKey返回static char loadOperationKey的地址)</div><div class="line">     */</div><div class="line">    <span class="built_in">NSMutableDictionary</span> *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="comment">//如果可以查到operations,就rerun,反之给视图绑定一个新的,空的operations字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;</div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="comment">/* 设置关联对象*/</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-dispatch-async和dispatch-sync-–-gt-GCD"><a href="#3-dispatch-async和dispatch-sync-–-gt-GCD" class="headerlink" title="3.dispatch_async和dispatch_sync –&gt; GCD"></a>3.dispatch_async和dispatch_sync –&gt; GCD</h3><p>这对方法都有两个参数(dispatch_queue_t queue, dispatch_block_t block)，一个队列和一个block；对于dispatch_async来说：他把block放到队列之中，之后立刻返回，继续往下执行。对于dispatch_sync来说：他把block放到队列之中，等待block执行完返回，之后才继续往下执行。</p>
<p>看下实际的代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//to show the difference of dispatch_async and dispatch_sync</span></div><div class="line"><span class="comment">//串行队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> _serialQueue = dispatch_queue_create(<span class="string">"com.example.name"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line"><span class="comment">//异步立刻返回.放打印放入到后台执行</span></div><div class="line"><span class="built_in">dispatch_async</span>(_serialQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(_serialQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line"></div><div class="line"><span class="comment">//同步等待block的代码执行完.放打印放入到后台执行</span></div><div class="line"><span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(_serialQueue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div></pre></td></tr></table></figure>
<p>对于<code>dispatch_async</code>来说,把block提交到队列,立刻返回执行下一步.不等待block执行完毕.所以它的打印结果有很多中,譬如说<code>2413 或者 2143或者 1234</code>,但是1总在3前面.因为提交到的队列是<code>串行队列</code>,打印3总在打印1后执行. </p>
<p>对于<code>dispatch_sync</code>来说,把block提交到队列,不立刻返回,它等待提交到队列的block执行完毕才继续向下执行.所以其执行结果只有一种: 1234.无论你运行多少次都会是这一种结果. </p>
<h3 id="4-block"><a href="#4-block" class="headerlink" title="4.block"></a>4.block</h3><p>代码块没什么好说的</p>
<h3 id="5-NSAssert"><a href="#5-NSAssert" class="headerlink" title="5.NSAssert"></a>5.NSAssert</h3><p>断言，防御式变成的常用手段</p>
<h3 id="6-NSOperation"><a href="#6-NSOperation" class="headerlink" title="6.NSOperation"></a>6.NSOperation</h3><p>NSOperation的抽象程度高于NSThread，它是苹果对线程的一个面向对象封装。NSOperation表示一个独立的计算单元，作为一个抽象类，你需要实例话他的子类 ?NSInvocationOperation / ?NSBlockOperation 来进行具体操作。实例化之后，调用start方法或者加入到一个NSOperationQueue 操作队列中，就可以开始执行。</p>
<h3 id="7-NSCache"><a href="#7-NSCache" class="headerlink" title="7.NSCache"></a>7.NSCache</h3><p>NSCache是系统提供的一种类似于集合（NSMutableDictionary）的缓存，它与集合的不同如下：</p>
<ol>
<li><p>NSCache具有自动删除的功能，以减少系统占用的内存；</p>
</li>
<li><p>NSCache是线程安全的，不需要加线程锁；</p>
</li>
<li><p>键对象不会像 NSMutableDictionary 中那样被复制。（键不需要实现 NSCopying 协议）</p>
</li>
</ol>
<h3 id="8-NSMutableURLRequest"><a href="#8-NSMutableURLRequest" class="headerlink" title="8.NSMutableURLRequest"></a>8.NSMutableURLRequest</h3><p>  网络请求参数配置</p>
<h3 id="9-NSURLConnection"><a href="#9-NSURLConnection" class="headerlink" title="9.NSURLConnection"></a>9.NSURLConnection</h3><p>网络请求系统框架集成</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/11/SDWebImage-简介/" data-id="cir1zqqnk00027p5hwymdbolh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第一篇github博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/05/第一篇github博客/" class="article-date">
  <time datetime="2016-07-05T14:47:41.000Z" itemprop="datePublished">2016-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/第一篇github博客/">第一篇github博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="生命不息折腾不止，经过两天的捣腾终于把github博客搭建起来了，不管怎么说，以后这里就作为自己的生涯记录了，加油！"><a href="#生命不息折腾不止，经过两天的捣腾终于把github博客搭建起来了，不管怎么说，以后这里就作为自己的生涯记录了，加油！" class="headerlink" title="生命不息折腾不止，经过两天的捣腾终于把github博客搭建起来了，不管怎么说，以后这里就作为自己的生涯记录了，加油！"></a>生命不息折腾不止，经过两天的捣腾终于把github博客搭建起来了，不管怎么说，以后这里就作为自己的生涯记录了，加油！</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/05/第一篇github博客/" data-id="cir1zqqnq00057p5h1eukgt7s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/25/NSCache初识/">NSCache初识</a>
          </li>
        
          <li>
            <a href="/2016/07/22/SDWebImage源码分析_02/">SDWebImage源码分析_02</a>
          </li>
        
          <li>
            <a href="/2016/07/22/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/07/12/SDWebImage源码分析-01/">SDWebImage源码分析_01</a>
          </li>
        
          <li>
            <a href="/2016/07/11/SDWebImage-简介/">SDWebImage 简介</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 郑广阔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>