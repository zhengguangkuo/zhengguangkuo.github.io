<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SDWebImage源码分析_02 | 学无止境</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="接续上一篇内容，首先我们看一下SDWebImageCombinedOperation这个类：1234567@interface SDWebImageCombinedOperation : NSObject &amp;lt;SDWebImageOperation&amp;gt;@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;@pr">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage源码分析_02">
<meta property="og:url" content="http://yoursite.com/2016/07/22/SDWebImage源码分析_02/index.html">
<meta property="og:site_name" content="学无止境">
<meta property="og:description" content="接续上一篇内容，首先我们看一下SDWebImageCombinedOperation这个类：1234567@interface SDWebImageCombinedOperation : NSObject &amp;lt;SDWebImageOperation&amp;gt;@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;@pr">
<meta property="og:updated_time" content="2016-07-22T09:28:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDWebImage源码分析_02">
<meta name="twitter:description" content="接续上一篇内容，首先我们看一下SDWebImageCombinedOperation这个类：1234567@interface SDWebImageCombinedOperation : NSObject &amp;lt;SDWebImageOperation&amp;gt;@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;@pr">
  
    <link rel="alternate" href="/atom.xml" title="学无止境" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">学无止境</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">蕴含文艺气息的程序猿</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-SDWebImage源码分析_02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/22/SDWebImage源码分析_02/" class="article-date">
  <time datetime="2016-07-22T12:59:24.000Z" itemprop="datePublished">2016-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SDWebImage源码分析_02
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接续上一篇内容，首先我们看一下SDWebImageCombinedOperation这个类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCombinedOperation</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageOperation</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) SDWebImageNoParamsBlock cancelBlock;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperation</span> *cacheOperation;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这里面主要保存了两个东西cancelBlock可以取消operation，cacheOperation用来下载图片并且缓存。</p>
<h3 id="下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中"><a href="#下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中" class="headerlink" title="下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中."></a>下面我们正式进入图片缓存的代码，图片缓存主要在SDImageCache这个类中.</h3><p>下面这个方法主要作用是异步查询图片缓存，分别从内存中查询和磁盘中查询，也是这个类的主要方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!doneBlock) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        doneBlock(<span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// First check the in-memory cache...</span></div><div class="line">    <span class="comment">// 1.首先查看内存缓存,如果查找到,则直接调用doneBlock并返回</span></div><div class="line">    <span class="comment">//这个 imageFromMemoryCacheForKey 方法会在 SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据, 而 memCache 就是一个 NSCache.</span></div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        doneBlock(image, SDImageCacheTypeMemory);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//2.如果内存中没有,则在磁盘中查找,如果找到,则将其放到内存缓存中,并调用doneBlock回调</span></div><div class="line">    <span class="comment">/*如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..*/</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    </div><div class="line">    <span class="comment">//在ioQueue中串行处理所有磁盘缓存</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//创建自动释放池,内存及时释放</span></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="comment">/* 在这里会调用一个方法 diskImageForKey, 这里文件名字的存储使用 MD5 处理过后的文件名，存储的内容是image的data数据*/</span></div><div class="line">            <span class="comment">//根据图片的url对应的key去磁盘缓存中查找图片</span></div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            </div><div class="line">            <span class="comment">// 获取图片后缓存到内存中</span></div><div class="line">            <span class="comment">//如果可以在磁盘中查找到image,并且self.shouldCacheImagesInMemory = YES(默认是YES,if memory cache is enabled)就将image储存到内存缓存中</span></div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                </div><div class="line">                <span class="comment">//self.memCache是NSCache创建的一个对象,下面的方法是NSCache储存对象的方法</span></div><div class="line">                <span class="comment">/**</span></div><div class="line">                 在缓存中设置指定键名对应的值，并且指定该键值对的成本。当出现内存警告时，或者超出缓存的总成本上限时，缓存会开启一个回收过程，删除部分元素</div><div class="line">                 @param cost 成本 (cost) 用于计算记录在缓冲中的所有对象的总成本</div><div class="line">                 */</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//最后在主线程里面调用doneBlock返回</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法中imageFromMemoryCacheForKey和diskImageForKey分别是从内存中查找和从磁盘中查找，下面我们看一下这两个方法的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上方法memCache是NSCache类型的属性，图片的缓存即是通过这个存储在内存中。</p>
<p>接着我们看磁盘缓存<br>在这里会调用一个方法 diskImageForKey, 这里文件名字的存储使用 MD5 处理过后的文件名，存储的内容是image的data数据<br>根据图片的url对应的key去磁盘缓存中查找图片<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)diskImageForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">    <span class="keyword">if</span> (data) &#123;</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:data];</div><div class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">            image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这些方法，把url用md5加密，拼接成filename，CC_MD5_DIGEST_LENGTH这个宏定义 = 16，r[16]开辟16字节的存储空间，然后把filename和文件路径绑定在一起。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单封装了cachePathForKey:inPath</span></div><div class="line">- (<span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cachePathForKey:key inPath:<span class="keyword">self</span>.diskCachePath];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// cachePathForKey:inPath</span></div><div class="line">- (<span class="built_in">NSString</span> *)cachePathForKey:(<span class="built_in">NSString</span> *)key inPath:(<span class="built_in">NSString</span> *)path &#123;</div><div class="line"><span class="comment">// 根据传入的key创建最终要存储时的文件名</span></div><div class="line"><span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> cachedFileNameForKey:key];</div><div class="line"><span class="comment">// 将存储的文件路径和文件名绑定在一起，作为最终的存储路径</span></div><div class="line"><span class="keyword">return</span> [path stringByAppendingPathComponent:filename];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// cachedFileNameForKey:</span></div><div class="line"><span class="comment">// 这个方法就是把key值即url，转化成32位16进制数，然后加上扩展名，座位文件名字。</span></div><div class="line">- (<span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = [key UTF8String];</div><div class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</div><div class="line">    str = <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用了MD5进行加密处理</span></div><div class="line"><span class="comment">// 开辟一个16字节（128位：md5加密出来就是128bit）的空间</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</div><div class="line"><span class="comment">// 官方封装好的加密方法</span></div><div class="line"><span class="comment">// 把str字符串转换成了32位的16进制数列（这个过程不可逆转） 存储到了r这个空间中</span></div><div class="line">CC_MD5(str, (CC_LONG)strlen(str), r);</div><div class="line"><span class="comment">// 最终生成的文件名就是 "md5码"+".文件类型"</span></div><div class="line"><span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</div><div class="line">                      r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</div><div class="line">                      r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], [[key pathExtension] isEqualToString:<span class="string">@""</span>] ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, [key pathExtension]]];</div><div class="line"></div><div class="line"><span class="keyword">return</span> filename;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。"><a href="#至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。" class="headerlink" title="至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。"></a>至此我们看完了图片缓存的代码，下面继续分析一下下载的相关实现。实现下载功能的类是SDWebImageDownloader。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageDownloaderOperation *operation;</div><div class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//创建下载的回调,我们开始来看看创建完下载的回调之后里面都写了什么事情</span></div><div class="line">        </div><div class="line">        <span class="comment">/* 请求超时时间*/</span></div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = wself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        <span class="comment">// 初始化NSMutableURLRequest 这个 request 就用于在之后发送 HTTP 请求</span></div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         创建请求对象,并根据options参数设置其属性</div><div class="line">         为了避免潜在的重复缓存(NSURLCache + SDImageCache)，</div><div class="line">         如果没有明确告知需要缓存，</div><div class="line">         则禁用图片请求的缓存操作, 这样就只有SDImageCache进行了缓存</div><div class="line">         这里的options 是SDWebImageDownloaderOptions</div><div class="line">         */</div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        <span class="comment">// 通过设置 NSMutableURLRequest.HTTPShouldHandleCookies = YES</span></div><div class="line">        <span class="comment">//的方式来处理存储在NSHTTPCookieStore的cookies</span></div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        <span class="comment">//返回在接到上一个请求得得响应之前,饰扣需要传输数据,YES传输,NO不传输</span></div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         如果你自定义了wself.headersFilter,那就用你自己设置的</div><div class="line">         wself.headersFilter来设置HTTP的header field</div><div class="line">         它的定义是</div><div class="line">         typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</div><div class="line">         一个返回结果为NSDictionary类型的block</div><div class="line">         </div><div class="line">         如果你没有自己设置wself.headersFilter那么就用SDWebImage提供的HTTPHeaders</div><div class="line">         HTTPHeaders在#import "SDWebImageDownloader.h",init方法里面初始化,下载webp图片需要的header不一样</div><div class="line">         (WebP格式，[谷歌]开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间)</div><div class="line">         #ifdef SD_WEBP</div><div class="line">         _HTTPHeaders = [@&#123;@"Accept": @"image/webp,image/*;q=0.8"&#125; mutableCopy];</div><div class="line">         #else</div><div class="line">         _HTTPHeaders = [@&#123;@"Accept": @"image/*;q=0.8"&#125; mutableCopy];</div><div class="line">         #endif</div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/* 在初始化了这个 request 之后, 又初始化了一个 SDWebImageDownloaderOperation 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 NSOperation 的子类*/</span></div><div class="line">        </div><div class="line">        <span class="comment">/*但是在初始化之后, 这个操作并不会开始(NSOperation 实例只有在调用 start 方法或者加入 NSOperationQueue 才会执行), 我们需要将这个操作加入到一个 NSOperationQueue 中.*/</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         创建SDWebImageDownLoaderOperation操作对象(下载的操作就是在SDWebImageDownLoaderOperation类里面进行的)</div><div class="line">         传入了进度回调,完成回调,取消回调</div><div class="line">         </div><div class="line">         @property (assign, nonatomic) Class operationClass;</div><div class="line">         将Class作为属性存储,初始化具体Class,使用的时候调用具体class的方法</div><div class="line">         */</div><div class="line"></div><div class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</div><div class="line">                                                             SDWebImageDownloader *sself = wself;</div><div class="line">                                                             <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                             __block <span class="built_in">NSArray</span> *callbacksForURL;</div><div class="line">                                                             <span class="comment">/**</span></div><div class="line">                                                              URLCallbacks是一个字典,key是url,value是一个数组,</div><div class="line">                                                              数组里面装的是字典,key是NSString代表着回调类型,value为block是对应的回调</div><div class="line">                                                              确保提交的block是指定队列中特定时段唯一在执行的一个.</div><div class="line">                                                              */</div><div class="line">                                                             </div><div class="line">                                                             <span class="built_in">dispatch_sync</span>(sself.barrierQueue, ^&#123;</div><div class="line">                                                                 <span class="comment">//根据key取出装了字典的数组</span></div><div class="line">                                                                 callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</div><div class="line">                                                             &#125;);</div><div class="line">                                                             </div><div class="line">                                                             <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                 <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                                     <span class="comment">//根据kProgressCallbackKey这个key取出进度的操作</span></div><div class="line">                                                                     SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">                                                                     <span class="comment">//返回已经接收的数据字节,以及未接收的数据(预计字节)</span></div><div class="line">                                                                     <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);</div><div class="line">                                                                 &#125;);</div><div class="line">                                                             &#125;</div><div class="line">                                                         &#125;</div><div class="line">                                                        completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                            <span class="comment">//依旧是根据url这个key取出一个里面装了字典的数组</span></div><div class="line">                                                            __block <span class="built_in">NSArray</span> *callbacksForURL;</div><div class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</div><div class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</div><div class="line">                                                                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                                                                    <span class="comment">//如果这个任务已经完成,就根据url这个key从URLCallbacks字典里面删除</span></div><div class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                                &#125;</div><div class="line">                                                            &#125;);</div><div class="line">                                                            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</div><div class="line">                                                                <span class="comment">//根据kCompletedCallbackKey这个key取出SDWebImageDownloaderCompletedBlock(完成的block)</span></div><div class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">                                                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">                                                            <span class="comment">//将url对应的所有回调移除</span></div><div class="line">                                                            SDWebImageDownloader *sself = wself;</div><div class="line">                                                            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</div><div class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                            &#125;);</div><div class="line">                                                        &#125;];</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">//上面 是SDWebImageDownloaderOperation *operation的创建,从这里开始就都是对operation的配置</span></div><div class="line">        </div><div class="line">        <span class="comment">// 设置是否需要解压</span></div><div class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         用户认证 NSURLCredential</div><div class="line">         当连接客户端与服务端进行数据传输的时候,web服务器</div><div class="line">         收到客户端请求时可能需要先验证客户端是否是正常用户,再决定是否返回该接口的真实数据</div><div class="line">         </div><div class="line">         NSURLCredential 身份认证</div><div class="line">         </div><div class="line">         认证过程</div><div class="line">         1.web服务器接收到来自客户端的请求</div><div class="line">         2.web服务并不直接返回数据,而是要求客户端提供认证信息,也就是说挑战是服务端向客户端发起的</div><div class="line">         2.1要求客户端提供用户名与密码挑战 NSInternetPassword</div><div class="line">         2.2 要求客户端提供客户端证书 NSClientCertificate</div><div class="line">         2.3要求客户端信任该服务器</div><div class="line">         3.客户端回调执行,接收到需要提供认证信息,然后提供认证信息,并再次发送给web服务</div><div class="line">         4.web服务验证认证信息</div><div class="line">         4.1认证成功,将最终的数据结果发送给客户端</div><div class="line">         4.2认证失败,错误此次请求,返回错误码401</div><div class="line"></div><div class="line">         </div><div class="line">         iOS7.0之前使用的网络框架是NSURLConnection,在 2013 的 WWDC 上，</div><div class="line">         苹果推出了 NSURLConnection 的继任者：NSURLSession</div><div class="line">         </div><div class="line">         SDWebImage使用的是NSURLConnection,这两种网络框架的认证调用的方法也是不一样的,有兴趣的可以去google一下这里只看下NSURLConnection的认证(在这里写看着有些吃力,移步到这个代码框外面阅读)</div><div class="line">         </div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wself.urlCredential) &#123;</div><div class="line">            operation.credential = wself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:wself.username password:wself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//根据下载选项SDWebImageDownloaderHighPriority设置优先级</span></div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">//只有将operation加入到这个下载队列中, 这个操作才会执行.</span></div><div class="line">        <span class="comment">//将下载操作加到下载队列中</span></div><div class="line">        [wself.downloadQueue addOperation:operation];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            </div><div class="line">            <span class="comment">/**</span></div><div class="line">             根据executionOrder设置操作的依赖关系</div><div class="line">             executionOrder代表着下载操作执行的顺序,它是一个枚举</div><div class="line">             SD添加下载任务是同步的，而且都是在self.barrierQueue这个并行队列中，</div><div class="line">             同步添加任务。这样也保证了根据executionOrder设置依赖关是正确的。</div><div class="line">             换句话说如果创建下载任务不是使用dispatch_barrier_sync完成的，而是使用异步方法 ，虽然依次添加创建下载操作A、B、C的任务，但实际创建顺序可能为A、C、B，这样当executionOrder的值是SDWebImageDownloaderLIFOExecutionOrder，设置的操作依赖关系就变成了A依赖C，C依赖B</div><div class="line">             </div><div class="line">             typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line">             // 默认值，所有的下载操作以队列类型执行,先被加入下载队列的操作先执行</div><div class="line">             SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line">             // 所有的下载操作以栈类型执行,后进先出,后被加入下载队列的操作先执行</div><div class="line">             SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">             &#125;;</div><div class="line">             */</div><div class="line">            </div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</div><div class="line">    <span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     Serial 串行 Concurrent并发</div><div class="line">     任务串行执行每次只有一个任务执行</div><div class="line">     任务并发执行就是同一时间可以有多个任务被执行</div><div class="line">     </div><div class="line">     Synchronous 同步</div><div class="line">     一个同步函数只有在它完成预定的任务才返回(返回的意思是:返回当前线程,线程继续向下执行任务,你可以自己做个测试用一个同步函数,任务里面sleep(3);测试一下就明白了)</div><div class="line">     </div><div class="line">     Asynchronous 异步</div><div class="line">     一个异步函数,会立即返回,预定任务会完成,但是不会等到这个任务完成才返回</div><div class="line">     </div><div class="line">     Queues 队列</div><div class="line">     GCD提供 dispatch queues来处理代码,这些队列管理你提供给GCD的任务并用FIFO顺序执行,这保证了第一个被添加到队列里的任务会是队列中第一个执行的,第二个被添加的任务第二个开始执行,如此直到队列的终点</div><div class="line">     只能保证任务开始的顺序不能保证任务结束的顺序</div><div class="line">     </div><div class="line">     Serial Queues 串行队列</div><div class="line">     串行队列的任务一次执行一个,每一个任务只有在前一个任务完成的时候才开始,但是你不知道一个任务(block)和下一个开始之间的时间长度</div><div class="line">     </div><div class="line">     Concurrent Queues 并发队列</div><div class="line">     在并发队列中的任务能得到的保证是它们会被按照被添加的顺序开始执行,任务能以任意顺序完成,但是你不知道什么时候才开始运行下一个任务,或者任意时刻有多少block在运行,这完全取决于GCD</div><div class="line">     </div><div class="line">     Queue Type 队列类型</div><div class="line">     主队列(main queue),和其它串行队列一样,这个队列中的任务一次只能执行一个,然后它能保证所有的任务都在主线程执行,而主线程是唯一可用于更新UI的线程,这个队列就是用于发消息给UIView或发送通知的</div><div class="line">     </div><div class="line">     全局调度队列(Global Dispatch Queues),它分了四种优先级(任务执行的优先级):background , low , default , high</div><div class="line">     Apple的API也会使用这些队列,所以你添加的任何任务都不会是这些队列唯一的任务</div><div class="line">     </div><div class="line">     自己创建的串行队列 或者并发队列</div><div class="line">     </div><div class="line">     GCD提供的函数</div><div class="line">     dispatch_async 异步 , 与其他线程无关</div><div class="line">     dispatch_sync 同步,阻塞其他线程</div><div class="line">     dispatch_apply 重复执行</div><div class="line">     dispatch_after 延迟执行</div><div class="line">     dispatch_barrier_async dispatch_barrier_sync(下面细讲)</div><div class="line">     </div><div class="line">     GCD的使用呢,总结起来就是先选用一个GCD提供的函数,传入一个你要调用的队列(三种队列类型的一种)和一个block(任务),</div><div class="line">     队列会在轮到这个block执行的时候执行这个block</div><div class="line">     </div><div class="line">     注意:队列是用来存放任务的,队列并不等于线程,队列中存放的任务最后都要由线程来执行</div><div class="line">     </div><div class="line">     */</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     再回到刚才要看的部分,dispatch_barrier_sync是我们选用的GCD提供的函数,self.barrierQueue是存放任务的队列,block里面是要执行的任务</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     先来看看dispatch_barrier_sync</div><div class="line">     Dispatch Barrier解决多线程并发读写一个资源发生死锁</div><div class="line">     sync说明了这是个同步函数,任务不会立即返回,会等到任务执行结束才返回</div><div class="line">     使用dispatch_barrier_sync此函数创建的任务会首先去查看队列中有没有别的任务要执行,如果有则会等待已有任务执行完毕再执行;同时在此方法后添加的任务必须等到此方法中任务执行后才能执行,利用这个方法可以控制执行顺序</div><div class="line">     Dispatch   Barrier确保提交的block是指定队列中特定时段唯一在执行的一个.在所有先于Dispatch Barrier的任务都完成的情况下这个block才开始执行.轮到这个block时barrier会执行这个block并且确保队列在此过程 不会执行其他任务.block完成后才恢复队列</div><div class="line">     */</div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         这是用户自己创建的队列,DISPATCH_QUEUE_CONCURRENT代表的是它是一个并行队列,为什么选择并发队列而不是串行队列我们来想一下:</div><div class="line">         串行队列可以保证任务按照添加的顺序一个个开始执行,并且上一个任务结束才开始下一个任务,这已经可以保证任务的执行顺序(或者说是任务结束的顺利)了,但是并行队列不一样,并发队列只能保证任务的开始,至于任务以什么样的顺序结束并不能保证但是并发队列使用Barrier却是可以保证的.</div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="comment">// 多线程并发开始，同步返回，这样的好处是减少多任务执行的时间</span></div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         URLCallbacks是一个可变字典,key是NSURL类型,value为NSMutableArray类型,value(数组里面)只包含一个元素,这个元素的类型是NSMutableDictionary类型,这个字典的key为NSString类型代表着回调类型,value为block,是对应的回调</div><div class="line">         这些代码的目的都是为了给url绑定回调</div><div class="line">         */</div><div class="line">        <span class="comment">/* 如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first 不为 YES 那么 HTTP 请求就不会被初始化, 图片也无法被获取.*/</span></div><div class="line">        <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</div><div class="line">            <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">            first = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Handle single download of simultaneous download request for the same URL</span></div><div class="line">        <span class="comment">// 然后, 在这个方法中会重新修正在 URLCallbacks 中存储的回调块.</span></div><div class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">        [callbacksForURL addObject:callbacks];</div><div class="line">        <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</div><div class="line">        </div><div class="line"></div><div class="line">        <span class="comment">/* 如果是第一次添加回调块, 那么就会直接运行这个 createCallback 这个 block, 而这个 block, 就是我们在前一个方法 downloadImageWithURL:options:progress:completed: 中传入的回调块.*/</span></div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         如果url第一次绑定它的回调,也就是第一次使用这个url创建下载任务则执行一次创建回调</div><div class="line">         在创建回调中 创建下载操作(下载操作并不是在这里创建的),dispatch_barrier_sync执行确保同一时间只有一个线程操作URLCallbacks属性,也就是确保了下面创建过程中在给operation传递回调的时候能取到正确的self.URLCallbacks[url]值,同事确保后面有相同的url再次创建的时候if (!self.URLCallbacks[url])分支不再进入,first==NO,也就不再继续调用创建回调,这样就确保了同一个url对应的图片不会重复下载</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (first) &#123;</div><div class="line">            createCallback();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">// 以上这部分代码总结起来只做了一件事情:在barrierQueue队列中创建下载任务</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中，-这个类就是处理-HTTP-请求-URL-连接的类-当这个类的实例被加入队列之后-start-方法就会被调用-而-start-方法首先就会产生一个-NSURLConnection"><a href="#当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中，-这个类就是处理-HTTP-请求-URL-连接的类-当这个类的实例被加入队列之后-start-方法就会被调用-而-start-方法首先就会产生一个-NSURLConnection" class="headerlink" title="当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中， 这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection."></a>当把下载操作添加到队列的时候，会触发下载的start方法，最终下载的核心代码在SDWebImageDownloaderOperation类中， 这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection.</h3><p>下面我们看一下start方法的实现<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*但是下面这个方法- (void)start就是关键了,它是对NSOperation- (void)start的重写,这个方法是执行下载任务的核心代码*/</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//先加一把线程锁,保证执行到这里的时候只有当前线程在执行下面的方法</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//如果下载操作被取消了</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            <span class="comment">//把下载相关的属性置为nil</span></div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         App 进入后台时,请求继续执行一段时间的方法,</div><div class="line">         使用UIApplication的beginBackgroundTaskWithExpirationHandler方法向系统借用一点时间，</div><div class="line">         继续执行下面的代码来完成connection的创建和进行下载任务。</div><div class="line">         */</div><div class="line">        </div><div class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sself) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">/**在后台任务执行时间超过最大时间时，</span></div><div class="line">                     也就是后台任务过期执行过期回调。</div><div class="line">                     在回调主动将这个后台任务结束。</div><div class="line">                     */</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">        <span class="comment">// 下载任务执行的状态,在执行是YES,不在执行时NO</span></div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">        <span class="comment">// //创建用于下载的connection 实例化connection</span></div><div class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</div><div class="line">        <span class="comment">//获取当前得得线程</span></div><div class="line">        <span class="keyword">self</span>.thread = [<span class="built_in">NSThread</span> currentThread];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// connection 开始运行开始下载</span></div><div class="line">    [<span class="keyword">self</span>.connection start];<span class="comment">//在 start 方法调用之后, 就是 NSURLConnectionDataDelegate 中代理方法的调用.</span></div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.connection) &#123;</div><div class="line">        <span class="comment">//任务开始立刻执行一次进度的回调</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 它会发出一个 SDWebImageDownloadStartNotification 通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//发送开始下载的通知</span></div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         在 [self.connection start];有返回结果(正常完成,有错误都算是结果)之前,</div><div class="line">         代码会一直阻塞在CFRunLoopRun()或者CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false) 这里,</div><div class="line">         也就是说  [self.connection start];之后下载就一直在进行中,一直到下载完成或者出错了(这两种情况都会调用CFRunLoopStop),这个阻塞才会解除</div><div class="line">         */</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (floor(<span class="built_in">NSFoundationVersionNumber</span>) &lt;= <span class="built_in">NSFoundationVersionNumber_iOS_5_1</span>) &#123;</div><div class="line">            <span class="comment">// Make sure to run the runloop in our background thread so it can process downloaded data</span></div><div class="line">            <span class="comment">// Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span></div><div class="line">            <span class="comment">//       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span></div><div class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CFRunLoopRun</span>();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         <span class="comment">//如果图片非正常的下载完成</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) &#123;</div><div class="line">            <span class="comment">//取消下载请求连接</span></div><div class="line">            [<span class="keyword">self</span>.connection cancel];</div><div class="line">            </div><div class="line">            <span class="comment">/**</span></div><div class="line">             NSURLConnectionDelegate代理方法</div><div class="line">             主动调用,并制造一个错误,这个方法一旦被调用</div><div class="line">             代理就不会再接收connection的消息,也就是不在调用其他的任何代理方法,connection彻底结束</div><div class="line">             */</div><div class="line">            </div><div class="line">            [<span class="keyword">self</span> connection:<span class="keyword">self</span>.connection didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@&#123;<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span>.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果connection创建失败,这里直接执行完成回调,并传递一个connection没有初始化的错误</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//执行到这里说明下载操作已经完成了(无论是成功还是错误),所以要停止在后台的执行,使用endBackgroundTask:</span></div><div class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></div><div class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行start之后下载操作正式开始，然后会回调NSURLConnectionDelegate里面一些方法，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在图片下载完成之后调用 completionBlock 来完成最后 UIImageView.image 的更新.</span></div><div class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)aConnection &#123;</div><div class="line">    </div><div class="line">    SDWebImageDownloaderCompletedBlock completionBlock = <span class="keyword">self</span>.completedBlock;</div><div class="line">    </div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         停止当前的runLoop,将connection属性和thread属性</div><div class="line">         发送下载停止的通知</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</div><div class="line">        <span class="keyword">self</span>.thread = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     检查sharedURLCache是否缓存了这次下载response</div><div class="line">     如果没有就把responseFromCached设置为NO</div><div class="line">     </div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (![[<span class="built_in">NSURLCache</span> sharedURLCache] cachedResponseForRequest:_request]) &#123;</div><div class="line">        responseFromCached = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     图片的缓存用的都是SDWebCache,所以就算设置了SDWebImageDownloaderIgnoreCachedResponse,</div><div class="line">     responseFromCached</div><div class="line">     回调的图片也是nil(理解有可能有偏差)</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) &#123;</div><div class="line">            completionBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">YES</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.imageData) &#123;</div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:<span class="keyword">self</span>.imageData];</div><div class="line">            <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">            image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">            </div><div class="line">            <span class="comment">// Do not force decoding animated GIFs // 注意对于gif图片,不需要解压缩</span></div><div class="line">            <span class="keyword">if</span> (!image.images) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//如果图片的大小为0 , 完成回调报错</span></div><div class="line">            <span class="keyword">if</span> (<span class="built_in">CGSizeEqualToSize</span>(image.size, <span class="built_in">CGSizeZero</span>)) &#123;</div><div class="line">                completionBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Downloaded image has 0 pixels"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//回调图片 已经图片的大小 完成状态YES</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                completionBlock(image, <span class="keyword">self</span>.imageData, <span class="literal">nil</span>, <span class="literal">YES</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//图片为空 回调 报错</span></div><div class="line">            completionBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Image data is nil"</span>&#125;], <span class="literal">YES</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.completionBlock = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将NSConnection 设置为完成状态</span></div><div class="line">    [<span class="keyword">self</span> done];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 会不停回调 progressBlock 来提示下载的进度.</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//'304 Not Modified' is an exceptional one</span></div><div class="line">    <span class="comment">//如果statusCode&lt;400并且不等304</span></div><div class="line">    <span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &lt; <span class="number">400</span> &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] != <span class="number">304</span>)) &#123;</div><div class="line">        </div><div class="line">         <span class="comment">//设置文件的预期大小,如果response.expectedContentLength &gt;0那么预期文件的大小就是response.expectedContentLength ,反之就是0</span></div><div class="line">        <span class="built_in">NSInteger</span> expected = response.expectedContentLength &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response.expectedContentLength : <span class="number">0</span>;</div><div class="line">        <span class="keyword">self</span>.expectedSize = expected;</div><div class="line">        <span class="comment">//立即完成一次进度回调</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, expected);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//初始化属性imageDate,用于拼接图片 二进制数据</span></div><div class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];</div><div class="line">        <span class="keyword">self</span>.response = response;</div><div class="line">        </div><div class="line">        <span class="comment">//异步的 向主队队列发送一个通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> code = [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode];</div><div class="line">        </div><div class="line">        <span class="comment">//This is the case when server returns '304 Not Modified'. It means that remote image is not changed.</span></div><div class="line">        <span class="comment">//In case of 304 we need just cancel the operation and return cached image from the cache.</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         如果 statusCode == 304 就调用[self cancelInternal]方法 ,或者取消self.connection的连接</div><div class="line">         取消操作,发送操作停止的通知,执行完成回调,停止当前的runloop,设置下载完成标记为YES,正在执行的为NO,将属性置为空</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">304</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> cancelInternal];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span>.connection cancel];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:[((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] userInfo:<span class="literal">nil</span>], <span class="literal">YES</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 会不停回调 progressBlock 来提示下载的进度.</span></div><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">        <span class="comment">// The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/</span></div><div class="line">        <span class="comment">// Thanks to the author @Nyx0uf</span></div><div class="line"></div><div class="line">        <span class="comment">// Get the total bytes downloaded</span></div><div class="line">        <span class="comment">// 根据self.imageData获取已接收的数据的长度</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</div><div class="line"></div><div class="line">        <span class="comment">// Update the data source, we must pass ALL the data, not just the new bytes</span></div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         每次接收到数据时,都会用现有的数据创建一个CGImageSourceRef对象以做处理,</div><div class="line">         而且这个数据应该是已接收的全部数据,而不仅仅是新的字节,所以才使用self.imageData作为参数(注意创建imageSource使用的数据是CoreFoundation的data,但是self.imageData是NSData,所以用(__bridge CFDataRef)self.imageData做转化 )</div><div class="line">         */</div><div class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         在首次接收到数据的时候,图片的长宽都是0(width+height == 0)</div><div class="line">         先从这些包含图像信息的数据中取出图像的长,宽,方向等信息以备使用</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//获取图片的属性信息</span></div><div class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">if</span> (properties) &#123;</div><div class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</div><div class="line">                <span class="comment">//图片像素的高度 可以前面加(__bridge NSNumber *)转换为NSNumber类型</span></div><div class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</div><div class="line">                <span class="comment">//获取图片的宽度</span></div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;width);</div><div class="line">                <span class="comment">//获取图片的朝向</span></div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">                <span class="comment">//CoreFoundation对象类型不在ARC范围内,需要手动释放资源</span></div><div class="line">                <span class="built_in">CFRelease</span>(properties);</div><div class="line"></div><div class="line">                <span class="comment">// When we draw to Core Graphics, we lose orientation information,</span></div><div class="line">                <span class="comment">// which means the image below born of initWithCGIImage will be</span></div><div class="line">                <span class="comment">// oriented incorrectly sometimes. (Unlike the image born of initWithData</span></div><div class="line">                <span class="comment">// in connectionDidFinishLoading.) So save it here and pass it on later.</span></div><div class="line">                </div><div class="line">                <span class="comment">/**</span></div><div class="line">                 使用Core Craphics框架绘制image时,使用的是</div><div class="line">                 initWithCGImage这个函数,但是使用这个函数有时候会造成图片朝向的错误,</div><div class="line">                 所以在这里保存朝向信息,orientation是一个可以记录图片方向的枚举</div><div class="line">                 */</div><div class="line">                </div><div class="line">                orientation = [[<span class="keyword">self</span> <span class="keyword">class</span>] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         width+height&gt;0 说明这时候已经接收到图片的数据了</div><div class="line">         totalSize &lt; self.expectedSize 说明图片 还没有接收完全</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</div><div class="line">            <span class="comment">// Create the image</span></div><div class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="meta">#ifdef TARGET_OS_IPHONE</span></div><div class="line">            <span class="comment">// Workaround for iOS anamorphic image 失真的变形的图片</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</div><div class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">                <span class="keyword">if</span> (bmContext) &#123;</div><div class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</div><div class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="literal">nil</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    image = scaledImage;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</div><div class="line">                        <span class="keyword">self</span>.completedBlock(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">CFRelease</span>(imageSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/22/SDWebImage源码分析_02/" data-id="ciqxjoy9b0000pk5hv1zejan4" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/07/12/SDWebImage源码分析-01/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ouder</strong>
      <div class="article-nav-title">SDWebImage源码分析_01</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/22/SDWebImage源码分析_02/">SDWebImage源码分析_02</a>
          </li>
        
          <li>
            <a href="/2016/07/12/SDWebImage源码分析-01/">SDWebImage源码分析_01</a>
          </li>
        
          <li>
            <a href="/2016/07/11/SDWebImage-简介/">SDWebImage 简介</a>
          </li>
        
          <li>
            <a href="/2016/07/05/第一篇github博客/">第一篇github博客</a>
          </li>
        
          <li>
            <a href="/2016/07/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 郑广阔<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>